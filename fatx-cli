#!/usr/bin/env bash
set -euo pipefail
#IFS=$'\n\t'

# fatx-cli is a Bash script wrapper for fatx (fatxfs), a userspace FATX
# filesystem driver (https://github.com/mborgerson/fatx).
#
# fatx-cli written primarily because fatx doesn't automagically mount F and G
# partitions (https://github.com/mborgerson/fatx/issues/30) yet.
#
# This script uses alot of bashism. Please use latest version of Bash.
#
# LICENSE ----------------------------------------------------------------------
#
# This is free and unencumbered software released into the public domain.
#
# Anyone is free to copy, modify, publish, use, compile, sell, or
# distribute this software, either in source code form or as a compiled
# binary, for any purpose, commercial or non-commercial, and by any
# means.
#
# In jurisdictions that recognize copyright laws, the author or authors
# of this software dedicate any and all copyright interest in the
# software to the public domain. We make this dedication for the benefit
# of the public at large and to the detriment of our heirs and
# successors. We intend this dedication to be an overt act of
# relinquishment in perpetuity of all present and future rights to this
# software under copyright law.
#
# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
# OTHER DEALINGS IN THE SOFTWARE.
#
# For more information, please refer to <http://unlicense.org>
#
# ------------------------------------------------------------------------------

print() { printf ':: %s\n' "$@" ;}
# Print green print,
print_g() { printf '\e[32m:: %s\n\e[m' "$@" ;}
# Print brown print.
print_w() { printf '\e[33m:: %s\n\e[m' "$@" ;}

# Checking dependencies:
declare -a DEPS=( awk fatxfs od )
for (( NUM=${#DEPS[@]}, i=0; i<NUM; i++ )); do
  if command -v "${DEPS[i]}" &>/dev/null ; then
    unset -v 'DEPS[i]'
  fi
done
if [[ "${#DEPS[@]}" -gt 0 ]]; then
  print_w    'Package(s) not found'
  print_w    'Install the proper distribution package for your system:'
  printf  '   - %s\n' "${DEPS[@]}"
  exit 1
fi

# VARIABLES --------------------------------------------------------------------

PARTINFO='/tmp/ogxptbl'
# Default partitions offset.
# PARTITION  OFFSET (hex)   SIZE (hex)       SIZE (dec)  SIZE (MB)
# 1. E       0xabe80000     0x1312d6000      5120024576       4882
# 2. C       0x8ca80000     0x1f400000        524288000        500
# 3. X       0x80000        0x2ee00000        786432000        750
# 4. Y       0x2ee80000     0x2ee00000        786432000        750
# 5. Z       0x5dc80000     0x2ee00000        786432000        750
declare -a RETAIL=(
'0x0055f400*0x200 0x009896b0*0x200'
'0x00465400*0x200 0x000fa000*0x200'
'0x00000400*0x200 0x00177000*0x200'
'0x00177400*0x200 0x00177000*0x200'
'0x002ee400*0x200 0x00177000*0x200'
)

declare -A XPART=( [0]="E" [1]="C" [2]="X" [3]="Y" [4]="Z" [5]="F" [6]="G" [e]="0" [c]="1" [x]="2" [y]="3" [z]="4" [f]="5" [g]="6" )

# FUNCTIONS --------------------------------------------------------------------

reconnect_qcow(){
  # This is dirty. I don't know how to mount multi partition of qcow2.
  # So we forced probe > unmount > disconnect > reconnect.
  sudo modprobe nbd max_part=8 &>/dev/null
  if grep "${1##*/}" /etc/mtab &>/dev/null; then
    MNTQCOW=$(grep -oP '(?<=fatxfs ).*?(?= fuse.fatxfs)' /etc/mtab | grep "${1##*/}")
    sudo umount -l "$MNTQCOW"
  fi
  sudo qemu-nbd --disconnect /dev/nbd0 &>/dev/null
  sudo qemu-nbd --connect=/dev/nbd0 "$1"
  DISK='/dev/nbd0'
}

dump_part_info() {
  DISK="$1"

  if [[ ${DISK##*.} == 'qcow2' ]]; then
    reconnect_qcow "$1"
  fi

  if lsblk -dno MODEL "$DISK" &>/dev/null; then
    MODEL="$(lsblk -dno MODEL "$DISK")"
  fi

  if [[ -z ${MODEL:-} ]]; then
    MODEL="${DISK##*/}"
  fi

  PARTINFO="${PARTINFO}-${MODEL// /_}"
  if [[ $(stat -c '%U' "$DISK") == "$USER" ]]; then
    dd if="$DISK" of="$PARTINFO" bs=512 count=1 status=none
  else
    sudo dd if="$DISK" of="$PARTINFO" bs=512 count=1 status=none
  fi

  if [[ ${DISK##*.} == 'qcow2' ]]; then
    sudo qemu-nbd --disconnect /dev/nbd0 &>/dev/null
  fi

  # Get active partitions and multiply it by 512.
  mapfile -t SECTOR < <(od -t x4 "$PARTINFO" | awk '/80000000/{ print "0x"$3"*0x200 0x"$4"*0x200" }')

  print_g "$DISK partition info has been dumped to ${PARTINFO}"
}

mount_partition() {
  local LBASize LBAStart SECTOR

  dump_part_info "$1" &>/dev/null

  if [[ ${#SECTOR[@]} -eq 0 ]]; then
    print_w "$1 doesn't have partition table"
    print "> Trying retail offset and size"
    SECTOR=( "${RETAIL[@]}" )
  fi

  if [[ $3 -ge ${#SECTOR[@]} ]]; then
    print_w "$1 does not have ${XPART[$3]} partition"
    exit
  fi

  LBAStart=$(printf '0x%x' "$((${SECTOR[$3]::16}))")
  LBASize=$(printf '0x%x' "$((${SECTOR[$3]:(-16)}))")

  sudo fatxfs -o allow_other "$1" "$2" --offset="${LBAStart}" --size="${LBASize}"
}

print_usage() {
  printf '%s\n' "
  ${0##*/} is a wrapper script for fatxfs, a userspace FATX filesystem driver.

  Usage: ${0##*/} -t TASK OPTIONS

  TASK:
    lsblk   List unmounted block device (connected disks).
    dump    Dump partition info of the Xbox disk (sector 0).
    list    List Xbox disk's partitions.
    mount   Mount Xbox disk's partition.

  OPTIONS:
    -d      Partitions's drive letter.
    -h      Print this text and exit.
    -i      Device to mount.
    -o      Mountpoint.
    -v      Script's version.

  Example:
    - List connected but unmounted block devices.
      ${0##*/} -t lsblk

    - Dump partition info of /dev/sdc.
      ${0##*/} -t dump -i /dev/sdc

    - List partitions of /dev/sda.
      ${0##*/} -t list -i /dev/sda

    - Mount F partition of /dev/sdc to ${HOME}/ogxhdd.
      ${0##*/} -t mount -o /dev/sdc -o ${HOME}/ogxhdd -d F
"
  exit
}
# MAIN -------------------------------------------------------------------------

# Cleanup after an unexpected event.
#trap 'rm -r "$TMPDIR"; exit' SIGINT ERR

# If this script run without argument.
[[ ${#@} -eq 0 ]] && print_usage

while getopts ":d:hi:o:t:v" opt; do
  case $opt in
    d)
      DRV="${OPTARG,,}"
    ;;
    h)
      print_usage
    ;;
    i)
      DISK="$OPTARG"
    ;;
    o)
      MNT="$OPTARG"
    ;;
    t)
      TASK="$OPTARG"
    ;;
    v)
      echo ':: fatx-cli v0.3 (2024.01.04) - written by si_kabayan'
      exit
    ;;
    \?)
      print_w "Wrong option: -$OPTARG" >&2
      exit 1
    ;;
    :)
      print_w "Option -$OPTARG need an argument" >&2
      exit 1
    ;;
  esac
done

case "$TASK" in
  lsblk)
    lsblk -Ado PATH,SIZE,MODEL
  ;;
  dump)
    if [[ -z ${DISK:-} ]]; then
      print_w 'Please define which disk to dump'
      print "Example: ${0##*/} -t dump -i /dev/sda"
      exit
    else
      dump_part_info "$DISK"
    fi
  ;;
  list)
    if [[ -z ${DISK:-} ]]; then
      print_w "List option need an argument"
      print "Example: ${0##*/} -t list -i /dev/sda"
      exit
    fi

    dump_part_info "$DISK" &>/dev/null

    if [[ ${#SECTOR[@]} -eq 0 ]]; then
      print_w "$DISK doesn't have partition table"
      exit
    fi

    # Print table header.
    printf  "\e[01;32m %-10s %-14s %-14s %12s %10s\n\e[m" \
            PARTITION \
            'OFFSET (hex)' \
            'SIZE (hex)' \
            'SIZE (dec)' \
            'SIZE (MB)'

    for (( NUM=${#SECTOR[@]}, i=0; i<NUM; i++ )); do
      PSTART="${SECTOR[i]}"
      PSTART="${PSTART%% *}"
      PEND="${SECTOR[i]}"
      PEND="${PEND##* }"
      LBAStart=$(printf '%x' "$((PSTART))")
      # Print table content.
      printf  " %-10s 0x%-12s 0x%-12x %12d %10d\n" \
              "$((i+1)). ${XPART[$i]}" \
              "$LBAStart" \
              "$((PEND))" \
              "$((PEND))" \
              "$(((PEND) / 0x100000))"
    done
  ;;
  mount)
    DRV="${DRV:-c}"

    if [[ -z $DISK ]]; then
      print_w "Please specify disk to mount"
      exit
    fi

    if [[ -z ${MNT:-} ]]; then
      if lsblk -dno MODEL "$DISK" &>/dev/null; then
        MNT="$(lsblk -dno MODEL "$DISK")"
        MNT="${HOME}/XBMount/${MNT// /-}_${DRV}"
      else
        MNT="${HOME}/XBMount/${DISK##*/}_${DRV}"
      fi
      mkdir -p "$MNT"
    fi

    if [[ ${DISK##*.} == 'qcow2' ]]; then
      print_w 'This will unmounting mounted partition of this disk'
      read -rp "Proceed (y/N)? " answer
      case "$answer" in
        y|Y )
          # continue
        ;;
        * )
          exit
        ;;
      esac
      reconnect_qcow "$DISK"
    fi

    if [[ ! -d $MNT ]]; then
      print_w "${MNT}: mount point does not exist."
      exit
    fi


    case "$DRV" in
      c|e|f|g|x|y|z)
        mount_partition "$DISK" "$MNT" "${XPART[$DRV]}"
      ;;
      *)
        print_w 'Mount option only accept C, E, F, G, X, Y and Z drive'
        exit
      ;;
    esac
    nemo --tabs --existing-window "$MNT"
  ;;
  *)
    print_usage
  ;;
esac